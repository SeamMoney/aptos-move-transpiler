/**
 * WASM Move Compiler Integration
 *
 * Runs the Move compiler v2 WASM binary via wasmtime to compile Move code
 * without requiring the Aptos CLI.
 *
 * Architecture:
 *   - Runtime: wasmtime CLI (no V8 stack/dep limits)
 *   - Framework deps (0x1::*, 0x3::*, 0x4::*) → all 137 precompiled bytecodes
 *   - evm_compat → pre-compiled bytecode (compiled offline via wasmtime)
 *   - User modules → compiled by wasmtime child process
 *
 * wasmtime has no stack limit, so all 137 framework deps + evm_compat can be
 * passed as precompiled_deps without crashing (unlike V8 WASI which hits
 * SIGABRT at ~39 deps).
 */

import { spawnSync, execFileSync } from 'child_process';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import type { CompileCheckResult, CompileCheckOptions, CompileDiagnostic } from './move-compiler.js';

// ─── Types ───────────────────────────────────────────────────────────

/** Options specific to WASM-based compilation. */
export interface WasmCompileCheckOptions extends CompileCheckOptions {
  /** Path to the move-compiler-v2.wasm binary */
  wasmPath: string;
  /** Path to framework-bytecodes.json (precompiled framework deps) */
  bytecodesPath: string;
}

/** WASM compiler output format (from move-compiler-v2.wasm). */
interface WasmCompilerOutput {
  success: boolean;
  modules: Record<string, string>;
  diagnostics?: WasmDiagnostic[];
}

interface WasmDiagnostic {
  severity: string;
  message: string;
  source?: string;
  line?: number;
  column?: number;
}

// ─── Caches ─────────────────────────────────────────────────────────

let _cachedBytecodes: Record<string, string> | null = null;
let _cachedBytecodesPath: string | null = null;
let _cachedEvmCompatBytecode: Record<string, string> | null = null;
let _wasmtimeAvailable: boolean | null = null;

/**
 * Load framework bytecodes as a flat map: "0x1::account" → base64 bytecode.
 */
function loadBytecodes(bytecodesPath: string): Record<string, string> {
  if (_cachedBytecodes && _cachedBytecodesPath === bytecodesPath) return _cachedBytecodes;
  const raw = readFileSync(bytecodesPath, 'utf-8');
  const parsed = JSON.parse(raw);

  const result: Record<string, string> = {};
  if (parsed.addresses) {
    for (const [addr, addrData] of Object.entries(parsed.addresses)) {
      const modules = (addrData as { modules: Record<string, string> }).modules;
      for (const [name, b64] of Object.entries(modules)) {
        result[`${addr}::${name}`] = b64;
      }
    }
  }

  _cachedBytecodes = result;
  _cachedBytecodesPath = bytecodesPath;
  return result;
}

/**
 * Load pre-compiled evm_compat bytecode.
 * The file is at src/stdlib/evm_compat_bytecode.json, generated by
 * scripts/precompile-evm-compat.mjs via wasmtime.
 *
 * Search strategy: walk up from process.cwd() looking for the file in
 * known locations (works in dev, dist, and bundler contexts).
 */
function loadEvmCompatBytecode(): Record<string, string> | null {
  if (_cachedEvmCompatBytecode !== undefined && _cachedEvmCompatBytecode !== null) {
    return _cachedEvmCompatBytecode;
  }

  // Known candidate paths relative to common base directories
  const candidates: string[] = [];
  const cwd = process.cwd();

  // When running from aptos-move-transpiler repo directly
  candidates.push(join(cwd, 'src', 'stdlib', 'evm_compat_bytecode.json'));

  // When running from sol2move-app (sibling repo)
  candidates.push(join(cwd, '..', 'aptos-move-transpiler', 'src', 'stdlib', 'evm_compat_bytecode.json'));

  // When linked via node_modules
  candidates.push(join(cwd, 'node_modules', 'sol2move', 'src', 'stdlib', 'evm_compat_bytecode.json'));

  for (const candidate of candidates) {
    if (existsSync(candidate)) {
      _cachedEvmCompatBytecode = JSON.parse(readFileSync(candidate, 'utf-8'));
      return _cachedEvmCompatBytecode;
    }
  }

  _cachedEvmCompatBytecode = null;
  return null;
}

// ─── Availability checks ────────────────────────────────────────────

/**
 * Check if the wasmtime CLI is available on the system.
 * Result is cached after the first call.
 */
function checkWasmtimeAvailable(): boolean {
  if (_wasmtimeAvailable !== null) return _wasmtimeAvailable;

  try {
    execFileSync('wasmtime', ['--version'], { stdio: 'pipe', timeout: 5000 });
    _wasmtimeAvailable = true;
  } catch {
    _wasmtimeAvailable = false;
  }

  return _wasmtimeAvailable;
}

/**
 * Check if the WASM compiler can be used.
 * Requires: wasmtime CLI + .wasm binary + framework-bytecodes.json.
 */
export function isWasmCompilerAvailable(wasmPath: string, bytecodesPath: string): boolean {
  return existsSync(wasmPath) && existsSync(bytecodesPath) && checkWasmtimeAvailable();
}

// ─── wasmtime runner ─────────────────────────────────────────────────

/**
 * Compile Move modules using the WASM compiler via wasmtime.
 *
 * Passes all 137 framework bytecodes + evm_compat as precompiled deps.
 * wasmtime has no stack/dep limit, so this works for any complexity of
 * transpiled contract (unlike V8 WASI which crashes at ~39 deps).
 */
export async function wasmCompileCheckModules(
  modules: { name: string; code: string }[],
  options: WasmCompileCheckOptions
): Promise<CompileCheckResult> {
  const {
    wasmPath,
    bytecodesPath,
    moduleAddress = '0x1',
    packageName = 'validation_check',
    timeout = 60000,
  } = options;

  // Validate paths
  if (!existsSync(wasmPath)) {
    return {
      success: false,
      errors: [{ message: `WASM binary not found: ${wasmPath}`, severity: 'error' }],
      warnings: [],
    };
  }
  if (!existsSync(bytecodesPath)) {
    return {
      success: false,
      errors: [{ message: `Framework bytecodes not found: ${bytecodesPath}`, severity: 'error' }],
      warnings: [],
    };
  }

  // Check wasmtime availability
  if (!checkWasmtimeAvailable()) {
    return {
      success: false,
      errors: [{
        message: 'wasmtime CLI not found. Install it: curl https://wasmtime.dev/install.sh -sSf | bash',
        severity: 'error',
      }],
      warnings: [],
    };
  }

  // Load all precompiled framework bytecodes (137 modules)
  const frameworkBytecodes = loadBytecodes(bytecodesPath);

  // Build sources map
  const sources: Record<string, string> = {};
  for (const mod of modules) {
    sources[`sources/${mod.name}.move`] = mod.code;
  }

  // Build precompiled deps: ALL framework bytecodes + evm_compat
  const precompiledDeps: Record<string, string> = { ...frameworkBytecodes };

  // Add pre-compiled evm_compat bytecode if user code references it
  const allCode = modules.map(m => m.code).join('\n');
  if (allCode.includes('evm_compat')) {
    const evmBytecode = loadEvmCompatBytecode();
    if (evmBytecode) {
      Object.assign(precompiledDeps, evmBytecode);
    } else {
      return {
        success: false,
        errors: [{
          message: 'evm_compat bytecode not found. Run: node scripts/precompile-evm-compat.mjs',
          severity: 'error',
        }],
        warnings: [],
      };
    }
  }

  // Build named addresses
  const namedAddresses: Record<string, string> = {
    std: '0x1',
    aptos_std: '0x1',
    aptos_framework: '0x1',
    aptos_token: '0x3',
    aptos_token_objects: '0x4',
    transpiler: '0x42',
    [packageName]: moduleAddress,
  };

  // Build WASM compiler input
  const compileInput = {
    sources,
    precompiled_deps: precompiledDeps,
    named_addresses: namedAddresses,
    package_name: packageName,
    output_encoding: 'base64',
  };

  // Run via wasmtime: pipe JSON to stdin, read JSON from stdout
  try {
    const inputJson = JSON.stringify(compileInput);

    const result = spawnSync('wasmtime', ['run', '--dir=/tmp', wasmPath], {
      input: inputJson,
      encoding: 'utf-8',
      timeout,
      stdio: ['pipe', 'pipe', 'pipe'],
      maxBuffer: 50 * 1024 * 1024, // 50MB
    });

    // Check for process-level errors
    if (result.error) {
      return handleSpawnError(result.error);
    }

    // Check for signal-based crashes
    if (result.signal) {
      return {
        success: false,
        errors: [{
          message: `WASM compiler crashed (${result.signal})`,
          severity: 'error',
        }],
        warnings: [],
      };
    }

    // Try to parse stdout as JSON result
    const stdout = result.stdout?.trim();
    if (stdout) {
      try {
        const wasmResult = JSON.parse(stdout) as WasmCompilerOutput;
        return mapWasmResult(wasmResult);
      } catch {
        // stdout wasn't valid JSON — fall through to error handling
      }
    }

    // Non-zero exit without parseable output
    if (result.status !== 0) {
      const stderr = result.stderr?.trim() || '';
      const truncated = stderr.length > 500 ? stderr.slice(0, 500) + '...' : stderr;
      return {
        success: false,
        errors: [{
          message: truncated || `WASM compiler exited with code ${result.status}`,
          severity: 'error',
        }],
        warnings: [],
      };
    }

    return {
      success: false,
      errors: [{ message: 'WASM compiler produced no output', severity: 'error' }],
      warnings: [],
    };
  } catch (error: unknown) {
    return handleSpawnError(error);
  }
}

// ─── Result mapping ──────────────────────────────────────────────────

function mapWasmResult(wasmResult: WasmCompilerOutput): CompileCheckResult {
  const errors: CompileDiagnostic[] = [];
  const warnings: CompileDiagnostic[] = [];

  if (wasmResult.diagnostics) {
    for (const diag of wasmResult.diagnostics) {
      const mapped: CompileDiagnostic = {
        message: diag.message,
        severity: diag.severity.toLowerCase() === 'warning' ? 'warning' : 'error',
        source: diag.source,
        line: diag.line,
        column: diag.column,
      };
      if (mapped.severity === 'warning') {
        warnings.push(mapped);
      } else {
        errors.push(mapped);
      }
    }
  }

  return {
    success: wasmResult.success,
    errors,
    warnings,
  };
}

function handleSpawnError(error: unknown): CompileCheckResult {
  const err = error as { message?: string; code?: string };

  let message = 'WASM compilation failed';
  if (err.code === 'ETIMEDOUT' || err.message?.includes('timed out')) {
    message = 'WASM compilation timed out';
  } else if (err.message) {
    message = `WASM compilation failed: ${err.message}`;
  }

  return {
    success: false,
    errors: [{ message, severity: 'error' }],
    warnings: [],
  };
}

/**
 * Reset caches (useful for testing).
 */
export function resetWasmCompilerCache(): void {
  _cachedBytecodes = null;
  _cachedBytecodesPath = null;
  _cachedEvmCompatBytecode = null;
  _wasmtimeAvailable = null;
}
